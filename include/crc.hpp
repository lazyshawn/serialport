#include <iostream>

/* **************************************************************************
 * ==>> Function:
 * 进行CRC-16/MODBUS计算
 * ==>> Parameters:
 * *arr: 输入数据数组指针; len: 数组长度.
 * **************************************************************************/
uint16_t getCrc16(uint8_t *arr, int len);

/* **************************************************************************
 * ==>> 测试网站
 * http://www.ip33.com/crc.html
 * **************************************************************************/
int main(int argc, char** argv) {
  uint8_t arr[] = {0x09, 0x10, 0x03, 0xE8, 0x00, 0x03, 0x06, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00};

  uint16_t crcInt = getCrc16(arr, sizeof(arr));;

  printf("crc16 hex is: %04X\n", crcInt);
  return 0;
}

/* **************************************************************************
 * 进行CRC-16/MODBUS计算
 * 生成CRC的流程为：
 * 1. 预置一个16位寄存器位FFFFH，称之为CRC寄存器。
 * 2. 把数据帧中第一个字节的8位与CRC寄存器中的低字节进行异或运算，
 *    结果存回CRC寄存器。
 * 3. 将CRC寄存器向右移1位，最高位以0填充，最低位移出并监测。
 * 4. 如果最低位为0: 重复第3步（下一次移位），如果最低位为1:
 *    则将CRC寄存器与一个预设的固定值（0A001H）进行异或运算。
 * 5. 重复第3步和第4步直到8次位移，这样就处理完了一个完整的8位。
 * 6. 重复第2步到第5步来处理下一个字节，知道处理完校验位前所有的数据。
 * 7. 最终CRC寄存器得值就是CRC的值。
 * **************************************************************************/
uint16_t getCrc16(uint8_t *arr, int len) {
  uint16_t crc = 0xFFFF, lsb;

  for (int i = 0; i < len; ++i) {
    crc ^= arr[i];
    for (int j = 0; j < 8; ++j) {
      lsb = crc & 0x0001;
      crc = crc >> 1;
      if (lsb != 0) {
        crc ^= 0xA001;
      }
    }
  }
  return crc;
}

